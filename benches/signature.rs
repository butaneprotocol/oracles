use std::{collections::BTreeMap, hint::black_box, str::FromStr as _};

use anyhow::Result;
use clap::Parser;
use criterion::{Criterion, criterion_group, criterion_main};
use frost_ed25519::{
    Identifier, SigningPackage, aggregate,
    keys::{self, IdentifierList, KeyPackage, PublicKeyPackage, SecretShare},
    round1, round2,
};
use num_bigint::BigUint;
use oracles::price_feed::{
    IntervalBound, IntervalBoundType, SyntheticPriceFeed, Validity, serialize,
};
use rand::{rngs::ThreadRng, thread_rng};

#[derive(Parser)]
struct Args {
    #[clap(long)]
    signer_count: usize,
    #[clap(long)]
    signed_packages: usize,
}

struct Node {
    identifier: Identifier,
    secret_key: SecretShare,
    key_package: KeyPackage,
}

fn generate_nodes(count: usize) -> Result<(Vec<Node>, PublicKeyPackage)> {
    let rng = thread_rng();
    let (shares, pubkey_package) =
        keys::generate_with_dealer(count as u16, count as u16, IdentifierList::Default, rng)?;
    let nodes = shares
        .into_iter()
        .map(|(identifier, secret_key)| {
            let (verifying_share, verifying_key) = secret_key.verify().unwrap();
            let key_package = KeyPackage::new(
                identifier,
                *secret_key.signing_share(),
                verifying_share,
                verifying_key,
                count as u16,
            );
            Node {
                identifier,
                secret_key,
                key_package,
            }
        })
        .collect();
    Ok((nodes, pubkey_package))
}

fn sign_package(
    nodes: &[Node],
    pubkeys: &PublicKeyPackage,
    payload: &SyntheticPriceFeed,
    rng: &mut ThreadRng,
) -> Result<()> {
    let mut nonces = vec![];
    let mut commitments = BTreeMap::new();
    for node in nodes {
        let (nonce, commitment) = round1::commit(node.secret_key.signing_share(), rng);
        nonces.push(nonce);
        commitments.insert(node.identifier, commitment);
    }

    let message = serialize(payload);
    let signing_package = SigningPackage::new(commitments, &message);

    let mut signature_shares = BTreeMap::new();
    for (node, nonce) in nodes.iter().zip(nonces) {
        let signature = round2::sign(&signing_package, &nonce, &node.key_package)?;
        signature_shares.insert(node.identifier, signature);
    }

    aggregate(&signing_package, &signature_shares, pubkeys)?;
    Ok(())
}

fn benchmark_size(c: &mut Criterion, count: usize) {
    let id = format!("{count} nodes");
    c.bench_function(&id, |b| {
        let (nodes, pubkeys) = generate_nodes(count).unwrap();
        let payload = generate_payload();
        let mut rng = thread_rng();
        b.iter(|| {
            sign_package(
                black_box(&nodes),
                black_box(&pubkeys),
                black_box(&payload),
                black_box(&mut rng),
            )
            .unwrap()
        });
    });
}

fn generate_payload() -> SyntheticPriceFeed {
    SyntheticPriceFeed {
        collateral_names: None,
        collateral_prices: vec![
            BigUint::from_str("30130397186607166875311325921434063851665359101359803164774410402440756508924619608173865557160841384292678578091900991201938799255854671416953442040504069970680284662640444338959336446126881726680736442467864402953750849094288232630930091015762275893722786435118835150218561792008412856824022267327308771").unwrap(),
            BigUint::from_str("12822069360269657657850159577352261759314706402540505860224978669152186480312171616942984419732010779476422612486019315435581979090250513268870833557430929850614651154217513323645497875731801790051140450690893331538657626143951442573938390935934159586935622997043667508619572268957313633091459218660205899").unwrap(),
            BigUint::from_str("124931577443347326756502538456598829412409238684223360617494801212819135144607164139800187559753147974964982391710869698771057370582865371548787634205990069682107251321108878994515854366278781742092470565039139932052509587024778458536238013965107304061989436158751419282336981407157987454070882252282324184472").unwrap(),
            BigUint::from_str("1064273007394515106778658969165168602716321089785437192884112650083829951765655920830186620978778892023727551087525159259665852577778103181849644391853796555211375307763572355989440528312929431149737777530218725619998863718326270398434912739452852345529979936576956420362985048736740548260487799977796921").unwrap(),
            BigUint::from_str("9779893107402465852110787993961413394978157756795259590151027534328609316830299735254299755433492462292115196320210528973554018882273028573355777064234219142141307095958277772194809394051354418850535645262131090551122517644200372883569608807897070781484020980671433924255126533305472253810695000711851502").unwrap(),
            BigUint::from_str("8924887856539379653732217578524738793522652910259773793334624751141230085542488733481973828568573397320582189831346145695993707366122351324812750874821573052059112032495583017420328697951138336902480753778305757923149771493332008219608706369891238833138871198365312422332586185147216655403344402788588479").unwrap(),
            BigUint::from_str("32619323991255775128981167781974868052905347646973518555822136226655374192776698247221830194942267059454828538146937647439416904849555917537331770849863969849968038097706170846793652891968458321392854787659432865535039459089616274443228098079155030994697286396211033938934103434588193193047247007034891442").unwrap(),
            BigUint::from_str("27399487322881862873944879827923172703280891297757712470620928851639348420886982216931610354865518122853397888236094893956944659590571118974450677400159010478987765446510339942925564474804038810462494711802693453608987095702285859561369466938019681008562317245637110326276989784018568506399693932058249999").unwrap(),
            BigUint::from_str("264595846963414036447098853282524023429274740983695386998525664742567916477448606660934022387472195103964993005337882361226329872005795883353279207919208290749870722763621793524128741356179742092425662014769195933949998026760801735732514342359217850314632731820919984420871671711019368122630638313779396").unwrap(),
            BigUint::from_str("2591201753983220965797614475261348586000679427356678779839727676352522035987434265551349622119143804723766851883787692873458084020633921710786456237616448966652321812708723344380464370462812961262483231804279701984182964459192202950170490926046227849706133845395574030624734274731464206387598507703691802").unwrap(),
            BigUint::from_str("88832806206737732383311398556269534900110072592038132940615597363185280298747932742518309293329545277172235731505339539502986283282698393229615989062327276174014492253721523092786783386045602901858553341871194430126248273634562841920707539232155915041007522914560853831790862256063546479784114819848223420").unwrap(),
            BigUint::from_str("76952700877889446363619954847499535942617252461777279639993600629268778967369282808182901719699458310833835241764198824235813501044921760327920362301672510753261346490303641539525939533622160541372043952134112900716514645643970234621334232779897716574157076037370210490898790860456752982829544094632529803477").unwrap(),
        ],
        synthetic: "MIDAS".to_string(),
        denominator: BigUint::from_str("158673541817500320825431451819770672558165252084210131047009883282639745225229822762806367070552426843102541989881591814331259214068373020948800596056804532763765348651752520899613464405819272658127459017326498741451759524302881547119932941353022837910729573625056651209120540554763235728360678807953234445").unwrap(),
        validity: Validity {
            lower_bound: IntervalBound {
                bound_type: IntervalBoundType::Finite(
                    1744319813531,
                ),
                is_inclusive: true,
            },
            upper_bound: IntervalBound {
                bound_type: IntervalBoundType::Finite(
                    1744320173531,
                ),
                is_inclusive: false,
            },
        },
    }
}

fn benchmark(c: &mut Criterion) {
    benchmark_size(c, 3);
    benchmark_size(c, 10);
    benchmark_size(c, 100);
    benchmark_size(c, 200);
}

criterion_group!(benches, benchmark);
criterion_main!(benches);
